-- @noindex
-- WalterBuilder/domain/serializer.lua
-- Generate WALTER code from element models

local Coordinate = require('WalterBuilder.domain.coordinate')

local M = {}

-- Serialize a single element
function M.serialize_element(element)
  if not element.visible then
    return "clear " .. element.id
  end
  return "set " .. element.id .. " " .. Coordinate.serialize(element.coords)
end

-- Serialize multiple elements grouped by context
function M.serialize_elements(elements, opts)
  opts = opts or {}
  local include_header = opts.include_header ~= false
  local include_comments = opts.include_comments ~= false

  local lines = {}

  if include_header then
    lines[#lines + 1] = "; Generated by WALTER Builder"
    lines[#lines + 1] = "; " .. os.date("%Y-%m-%d %H:%M")
    lines[#lines + 1] = ""
  end

  -- Group elements by context (tcp, mcp, etc.)
  local by_context = {}
  for _, element in ipairs(elements) do
    local ctx = element:get_context()
    if not by_context[ctx] then
      by_context[ctx] = {}
    end
    by_context[ctx][#by_context[ctx] + 1] = element
  end

  -- Output by context
  local contexts_order = {"tcp", "mcp", "envcp", "trans", "master.tcp", "master.mcp"}
  for _, ctx in ipairs(contexts_order) do
    local ctx_elements = by_context[ctx]
    if ctx_elements and #ctx_elements > 0 then
      if include_comments then
        lines[#lines + 1] = "; " .. ctx:upper() .. " elements"
      end

      for _, element in ipairs(ctx_elements) do
        lines[#lines + 1] = M.serialize_element(element)
      end
      lines[#lines + 1] = ""
    end
  end

  return table.concat(lines, "\n")
end

-- Serialize as a named layout
function M.serialize_layout(name, elements, opts)
  opts = opts or {}
  local image_dir = opts.image_dir

  local lines = {}

  lines[#lines + 1] = string.format('Layout "%s"%s', name, image_dir and (' "' .. image_dir .. '"') or "")
  lines[#lines + 1] = ""

  for _, element in ipairs(elements) do
    lines[#lines + 1] = "  " .. M.serialize_element(element)
  end

  lines[#lines + 1] = ""
  lines[#lines + 1] = "EndLayout"

  return table.concat(lines, "\n")
end

-- Generate a complete rtconfig.txt snippet
function M.generate_rtconfig(layouts, opts)
  opts = opts or {}
  local include_header = opts.include_header ~= false

  local lines = {}

  if include_header then
    lines[#lines + 1] = "; ============================================="
    lines[#lines + 1] = "; WALTER Layout Configuration"
    lines[#lines + 1] = "; Generated by WALTER Builder"
    lines[#lines + 1] = "; ============================================="
    lines[#lines + 1] = ""
  end

  for _, layout in ipairs(layouts) do
    lines[#lines + 1] = M.serialize_layout(layout.name, layout.elements, layout.opts)
    lines[#lines + 1] = ""
  end

  return table.concat(lines, "\n")
end

-- Parse WALTER code into elements (basic parser)
function M.parse_walter(code)
  local elements = {}
  local current_layout = nil

  for line in code:gmatch("[^\r\n]+") do
    -- Skip comments and empty lines
    local trimmed = line:match("^%s*(.-)%s*$")
    if trimmed ~= "" and not trimmed:match("^;") then

      -- Check for Layout start
      local layout_name = trimmed:match('^Layout%s+"([^"]+)"')
      if layout_name then
        current_layout = layout_name
      end

      -- Check for EndLayout
      if trimmed:match("^EndLayout") then
        current_layout = nil
      end

      -- Check for set command
      local element_id, coords_str = trimmed:match('^%s*set%s+([%w._]+)%s+(.+)$')
      if element_id and coords_str then
        local coords = Coordinate.parse(coords_str)
        if coords then
          elements[#elements + 1] = {
            id = element_id,
            coords = coords,
            layout = current_layout,
          }
        end
      end

      -- Check for clear command
      local clear_id = trimmed:match('^%s*clear%s+([%w._]+)$')
      if clear_id then
        elements[#elements + 1] = {
          id = clear_id,
          cleared = true,
          layout = current_layout,
        }
      end
    end
  end

  return elements
end

-- Format a coordinate value for display
function M.format_value(value)
  if value == math.floor(value) then
    return tostring(math.floor(value))
  else
    return string.format("%.2f", value):gsub("%.?0+$", "")
  end
end

-- Generate a coordinate explanation comment
function M.explain_coordinate(element)
  local c = element.coords
  local lines = {}

  lines[#lines + 1] = string.format("; %s: %s", element.id, element.name or "")
  lines[#lines + 1] = string.format(";   Position: (%s, %s)", M.format_value(c.x), M.format_value(c.y))
  lines[#lines + 1] = string.format(";   Size: %s x %s", M.format_value(c.w), M.format_value(c.h))

  if c.ls ~= 0 or c.ts ~= 0 or c.rs ~= 0 or c.bs ~= 0 then
    lines[#lines + 1] = string.format(";   Attachments: L=%s T=%s R=%s B=%s",
      M.format_value(c.ls), M.format_value(c.ts),
      M.format_value(c.rs), M.format_value(c.bs))

    -- Explain behavior
    local h_behav = Coordinate.get_horizontal_behavior(c)
    local v_behav = Coordinate.get_vertical_behavior(c)

    local behaviors = {}
    if h_behav == "stretch_end" then
      behaviors[#behaviors + 1] = "stretches right"
    elseif h_behav == "stretch_start" then
      behaviors[#behaviors + 1] = "stretches left"
    elseif h_behav == "move" and c.ls > 0 then
      behaviors[#behaviors + 1] = "moves horizontally"
    end

    if v_behav == "stretch_end" then
      behaviors[#behaviors + 1] = "stretches down"
    elseif v_behav == "stretch_start" then
      behaviors[#behaviors + 1] = "stretches up"
    elseif v_behav == "move" and c.ts > 0 then
      behaviors[#behaviors + 1] = "moves vertically"
    end

    if #behaviors > 0 then
      lines[#lines + 1] = ";   Behavior: " .. table.concat(behaviors, ", ")
    end
  end

  return table.concat(lines, "\n")
end

return M
